% !TeX root = RJwrapper.tex
\title{\{detourr\}: Interactive and Performant Tour Animations}
\author{by Casper Hart}

\maketitle

\abstract{%
The tour provides a useful vehicle for exploring high dimensional
datasets. It works by combining a sequence of projections---the tour
path---in to an animation---the display method. Current display
implementations in R are limited in their interactivity and portability,
and give poor performance and jerky animations even for small datasets.
We take a detour into web technologies, such as Three.js and WebGL, to
support smooth and performant tour visualisations. The R package
\{detourr\} implements a set of display tools using \{htmlwidgets\} and
TypeScript that allow for rich interactions (including orbit controls,
scrubbing, and brushing) and smooth animations for large datasets. It
provides a declarative R interface which is accessible to new users, and
it supports linked views using \{crosstalk\} and \{shiny\}. The
resulting animations are portable across a wide range of browsers and
devices. We also extend the radial transformation of the Sage Tour
(\citet{laa2021burning}) to 3 or more dimensions with an implementation
in 3D, and provide a simplified implementation of the Slice Tour
(\citet{laa2020slice}).
}

\hypertarget{ch:intro}{%
\section{Introduction}\label{ch:intro}}

An important first step in any data analysis task is to plot the data so
that we can get an intuitive understanding of its structure, for example
identifying the presence of clusters or outliers. When the data consists
of one or two variables this is quite straightforward, but as the
dimensionality of the data increases it becomes more difficult to
visualise.

Several methods exist for high dimensional data visualisation. Given a
data matrix \(\mathbf X\) we can simply plot each variable
\(X_1 \dots X_p\) against the others in a pairwise fashion with the
result being a scatterplot matrix (e.g. \citep{becker1987brushing}). We
can also view projections of our data by calculating
\(\mathbf Y = \mathbf X \mathbf A\) where \(\mathbf A\) is a
\(p \times d\) projection matrix with \(d\) usually being 1 or 2. We can
choose \(\mathbf A\) in several different ways, some examples being
Principal Component Analysis (PCA) which chooses the directions which
explain the maximum variance, and Linear Descriminant Analysis (LDA)
which maximises the ratio of between-group and within-group sums of
squares. The scatterplot matrix can also be thought of as a projection
method where the projections are parallel to each pair of coordinate
axes. These are all examples of \emph{linear dimension reduction}
techniques, but non-linear techniques are also available such as t-SNE
\citep{van2008tsne} and UMAP \citep{mcinnes2018umap} that aim to
preserve both local and global structure of the data.

Rather than generating a single static visual, the \emph{tour}
\citep{asimov1985grand}; \citep{buja2005computational} works by
combining a smooth sequence of projections in to an animation, which can
then be viewed using a variety of different \emph{display methods}
\citep{wickham2011tourr}. This allows the viewer to explore the data
from a number of different perspectives while being able to visually
connect what would otherwise be disjointed views. However, existing
display implementations for tours in R are limited in their
interactivity, performance, and portability, and generally result in
jerky animations even for small datasets.

In this paper we introduce a new R package called \CRANpkg{detourr},
which provides portable and performant display methods for tours.
Chapter \ref{ch:litreview} gives an overview of tours and reviews a few
existing software implementations. Chapter \ref{ch:implementation}
describes how the software is used, and Chapter \ref{ch:webtechnologies}
highlights some of the implementation decisions that were made regarding
performance. A case study using embeddings created from the MNIST
\citep{lecun1998mnist} dataset is presented in Chapter
\ref{ch:casestudy}, and Chapter \ref{ch:futurework} discusses how this
work might be extended in future.

\pagebreak

\hypertarget{ch:litreview}{%
\section{Background and related works}\label{ch:litreview}}

At its core, the tour is a sequence of projections of a data set that
are combined together to form an animation. If we denote an
\(n \times p\) data matrix \(\mathbf X\) and a \(p \times d\) projection
matrix \(\mathbf A\), then we can denote our \(n \times d\) projected
data set \(\mathbf Y\) as \(\mathbf Y = \mathbf X \mathbf A\).

Each projection matrix \(\mathbf A\) is often referred to as a
\emph{plane}, \emph{frame}, or \emph{basis}. (Note that in this paper,
the term \emph{frame} is avoided in this context to avoid ambiguity with
\emph{animation frames}). These bases are constrained to be orthonormal,
so each column of \(\mathbf A\) is a unit vector, and is orthogonal to
each other column. In order to produce a smooth animation, a set of
target bases are selected and interpolated between. Geodesic
interpolation is generally used as described in
\citep{buja2005computational}.

\hypertarget{types-of-tours}{%
\subsection{Types of tours}\label{types-of-tours}}

Different tour paths arise from using different methods for selecting
the target bases. For example, the \emph{grand tour} was introduced by
\citep{asimov1985grand} and chooses a set of target projections at
random. This can be thought of as a random walk around projections of
the data.

The projection pursuit guided tour chooses bases to find a more
interesting projection than the current one, where the interestingness
is defined by some index function. Index functions such as \emph{central
mass}, \emph{holes}, and \emph{lda} are described in
\citep{cook2007interactive}.

Other types of tours include the \emph{little tour}, which ensures bases
parallel to the axes are visited; the \emph{frozen tour} will fix some
of the values in the projection matrix \(\mathbf A\) between bases; the
local tour chooses bases that are within some angular distance of the
starting basis.

In all of these, the tour path is calculated in two steps; the target
basis is calculated and then interpolation is done so that the
transition to the next basis is smooth. Some methods generate the tour
path in a single step, for example the \CRANpkg{langevitour} package in
R \citep{harrison2022langevitour} produces tours as more of a physics
simulation where points have position, velocity, momentum, and damping,
and the position of points in subsequent animation frames is allowed to
evolve while taking in to account user interactions.

\hypertarget{display-methods}{%
\subsection{Display methods}\label{display-methods}}

The typical display methods for tours include histograms or density
plots for 1D projections, and x-y scatter plots for 2D ones. 3D data can
be viewed by a 3D scatterplot with a virtual perspective camera to
enable displaying on a monitor. This can be enhanced with fog to make
closer points more prominent, and interactive rotation controls to give
a more immersive 3D experience. Projections with 3 or more dimensions
can be displayed using parallel coordinates plots. Other displays exist
such as Andrew's plot \citep{andrews1972plots}, where each point is
represented by a fourier curve plotted between \(-\pi\) and \(\pi\).

These display methods can be enhanced to display additional information,
for example the \emph{slice tour} described in \citep{laa2020slice}
highlight points whose orthogonal distance to the projection plane is
smaller than some threshold, and fade out points that are further away.
This is good for finding hollowness in data, with an example shown in
the case study in Chapter \ref{ch:casestudy}.

Furthermore, the data may be transformed after being projected. One
consequence of the curse of dimensionality is that when projecting from
high to low dimensions, the points tend to crowd towards the center.
\citep{laa2021burning} describes the \emph{sage tour}, and provides a
radial transformation that ensures the relative volume at a radius \(r\)
in the data space is preserved in the projected space. The effect of
this is that the crowding is reduced, and uniformly distributed data in
the original space will continue to be uniform in the projected space.

\hypertarget{software-implementations}{%
\subsection{Software implementations}\label{software-implementations}}

The \CRANpkg{tourr} package \citep{wickham2011tourr} is the most
prevalent and comprehensive software in R \citep{R} for visualising
tours. It implements many of the tour paths described previously
including grand, little, guided, frozen, etc. and display methods
including scatter plots (with variations for the sage and slice tour),
parallel coordinates plots, depth displays, Andrew's plot. The package
also allows exporting tours as GIF images via the \CRANpkg{gifski}
package \citep{gifski}, or exporting to GGobi \citep{swayne2003ggobi} to
allow for interaction and linked brushing, etc. However, the
\CRANpkg{tourr} package uses the R graphics device as the primary
display, which is quite limited in performance and interactivity.

The \CRANpkg{spinifex} package \citep{spinifex} provides manual tours
built on \CRANpkg{tourr} and using R \CRANpkg{shiny} \citep{shiny}, and
allows the user to manipulate the contribution of each variable one at a
time. The \CRANpkg{liminal} R package \citep{lee2021liminal} provides an
interactive gadget for displaying tour visuals. Linked selection and
brushing is implemented on both visuals, and play / pause / restart
controls are provided.

The \CRANpkg{langevitour} R package instead uses the
\CRANpkg{htmlwidgets} package \citep{htmlwidgets} to display the tour.
The main calculations are performed in JavaScript and the points are
displayed as a scatter plot using HTML5 Canvas. The displays have good
performance so large numbers of data points can be plotted with the
animation remaining smooth, and includes interactive features such as
drag-and-drop of additional plot elements, and modifying parameters of
the tour and having the changes reflected in real time. Once the tour
visualisation is generated it then no longer relies on the R runtime so
it can be easily exported and embedded on a website for example. But
this package is developed with a particular focus of visualising physics
dynamics, rather than the more classical tour methods like in
\CRANpkg{tourr}.

\citep{kipp2019connecting} uses D3.js \citep{bostock2011d3} combined
with the R \CRANpkg{shiny} \citep{shiny} package to display dynamic tour
visualisations. However, this setup had limited performance; the
client-server nature of \CRANpkg{shiny} led to inconsistent frame rates,
and the number of points that could be drawn was limited to
\textless2000 because of the limitations of SVG when drawing many
individual elements.

\pagebreak

\hypertarget{ch:implementation}{%
\section{\{detourr\} usage and interactivity}\label{ch:implementation}}

The \{tourr\} package implements a functional approach to building tours
can be intimidating to new users. Further, the use of the R graphics
device and exporting of GIF images limit the interactivity that can be
achieved. When designing the user API for \{detourr\} a data-oriented
approach is taken to make it more approachable, and the visuals are
built in JavaScript to enable rich user interactions. \{detourr\} also
supports the full suite of tour path generating functions from the
\{tourr\} package. The result is an experience that is powerful,
immersive, and accessible to newcomers.

This chapter is structured as follows. The first section describes the
user API in R and supported features, the second describes how the user
can interact with the resulting visual. Throughout the chapter, we use
the \texttt{pdfSense} dataset (\citet{wang2018mapping};
\citet{lee2021liminal}) to provide a running example. This data set
consists of 2808 observations and 56 input variables from CT14HERA
parton distribution function fits. The first 6 principal components are
used to create the tour, accounting for \textasciitilde55\% of the
variance in the data.

\hypertarget{user-interface}{%
\subsection{User interface}\label{user-interface}}

\{detourr\} has a data-oriented user interface heavily influenced by the
Tidy Data (\citet{tidydata}) workflow, Grammar of Graphics
(\citet{wilkinson2012grammar}; \citet{wickham2010layered}), and
\{ggplot2\} (\citet{wickham2016ggplot2}). The visualisation is built in
a sequence of steps which follow the logical flow of data in the tour
building process, which makes the API intuitive and accessible.

\hypertarget{instantiating-the-tour}{%
\subsubsection{Instantiating the tour}\label{instantiating-the-tour}}

To begin, we instantiate a tour using the \texttt{detour()} function:

\begin{Schunk}
\begin{Sinput}
p <- detour(pdf_df, tour_aes(
    projection = starts_with("PC"),
    colour = Type,
    label = ID
))
\end{Sinput}
\end{Schunk}

The first argument to \texttt{detour()} is a data frame in tidy format
containing the tour data and aesthetics. Enforcing the use of data
frames encourages data-centric statistical thinking. The second argument
defines the aesthetic mapping of data variables through the
\texttt{tour\_aes()} function, similar to \{ggplot2\}. The currently
supported aesthetics are:

\begin{itemize}
\tightlist
\item
  \texttt{projection}: (required) the numeric columns to be projected
\item
  \texttt{colour}: point colour
\item
  \texttt{label}: label text to be shown when the mouse is hovered over
  a point.
\end{itemize}

These mappings support tidy evaluation and \{tidyselect\} syntax
(\citet{tidyselect}) such as \texttt{starts\_with()},
\texttt{where(is.numeric())}, column ranges using
\texttt{col\_1:col\_n}, negation \texttt{-col\_n}, and others, for
easier column selection.

\hypertarget{generating-the-tour-path}{%
\subsubsection{Generating the tour
path}\label{generating-the-tour-path}}

Once the tour is initialised with the data and aesthetics, the tour path
is defined by piping the output from \texttt{detour()} to the
\texttt{tour\_path()} function. Note that
\texttt{\textbar{}\textgreater{}} is the pipe operator introduced in R
4.1:

\pagebreak

\begin{Schunk}
\begin{Sinput}
p <- p |> tour_path(grand_tour(3))
p
\end{Sinput}
\begin{Soutput}
#> # A tibble: 471 x 2
#>   is_new_basis projection_matrix
#>   <lgl>        <list>           
#> 1 TRUE         <dbl [6 x 3]>    
#> 2 FALSE        <dbl [6 x 3]>    
#> 3 FALSE        <dbl [6 x 3]>    
#> 4 FALSE        <dbl [6 x 3]>    
#> 5 FALSE        <dbl [6 x 3]>    
#> # ... with 466 more rows
\end{Soutput}
\end{Schunk}

The \texttt{tour\_path()} function defines parameters for the tour such
as:

\begin{itemize}
\tightlist
\item
  \texttt{tour\_path}: the tour path generator,
  e.g.~\texttt{grand\_tour()}, \texttt{guided\_tour()}, or any other
  path generator compatible with the \{tourr\} package
\item
  \texttt{start}: the starting basis or projection matrix
\item
  \texttt{fps} frames per second with which to display the animation.
  Defaults to 30 but can be increased for a smoother animation or
  decreased for very large data.
\item
  \texttt{max\_bases}: the number of basis frames to generate. A higher
  number will give a longer tour animation.
\end{itemize}

The resulting \texttt{detour} object is stored in a standard data frame
for easy consumption and inspection. It contains the full details of the
tour path, where the \(i^{th}\) row corresponds to the \(i^{th}\)
animation frame of the tour, with the following columns:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \texttt{is\_new\_basis}: whether the projection matrix corresponds to
  a new basis (\texttt{TRUE}) or is interpolated (\texttt{FALSE})
\item
  \texttt{projection\_matrix}: the projection matrix.
\end{enumerate}

This form gives the user full visibility of the tour path, and allows
the projection matrices to be traced and extracted for further analyses.

\hypertarget{creating-the-animation}{%
\subsubsection{Creating the animation}\label{creating-the-animation}}

To display the tour animation, we simply pipe the output of
\texttt{tour\_path()} to any of the functions prefixed with
\texttt{show\_} provided by the \{detourr\} package. The available
display functions are:

\begin{itemize}
\tightlist
\item
  \texttt{show\_scatter()}: the core 2D or 3D scatter plot display
\item
  \texttt{show\_slice()}: a slice tour display based on
  \citet{laa2020slice}
\item
  \texttt{show\_sage()}: a sage tour implementation based on
  \citet{laa2021burning}
\end{itemize}

\begin{Schunk}
\begin{Sinput}
p |> show_scatter(axes = FALSE)
\end{Sinput}
\end{Schunk}

\begin{Schunk}
\begin{figure}
\includegraphics[width=\textwidth]{figures/implementation/pdfsense_scatter_3d} \caption[Initial frame of the scatterplot display generated by the `show\_scatter` display function]{Initial frame of the scatterplot display generated by the `show\_scatter` display function. Controls are on the left, and an interactive timeline is on the bottom of the plot.}\label{fig:scatter-display}
\end{figure}
\end{Schunk}

The output of \texttt{tour\_path()} becomes the input of
\texttt{show\_*()}, forming a fluent pipeline. For the three display
methods described above, the common parameters are:

\begin{itemize}
\tightlist
\item
  \texttt{palette}: the colour palette to use for the tour.
\item
  \texttt{center}: whether the data should be centered before
  displaying.
\item
  \texttt{axes}: whether to show axis / what the axis titles should be
\item
  \texttt{edges}: a two-column numeric matrix defining indices of points
  where line segments should be drawn between
\item
  \texttt{paused}: whether the animation should be initialised in a
  paused state.
\item
  \texttt{scale\_factor}: used to scale the points in or out so that
  they appear on a sensible range.
\end{itemize}

There are also parameters specific to each display method, such as
\texttt{slice\_relative\_volume} for \texttt{show\_slice()}, and
\texttt{gamma} and \texttt{R} for \texttt{show\_sage()}. These details
will be described further in Section \ref{ch:display-methods}.

Putting all of this together, we have:

\begin{Schunk}
\begin{Sinput}
detour(pdf_df, tour_aes(
    projection = starts_with("PC"),
    colour = Type,
    label = ID
)) |>
    tour_path(grand_tour(3)) |>
    show_scatter()
\end{Sinput}
\end{Schunk}

This chaining process allows us to construct the tour visualisation
incrementally in a way that is intuitive and easy to follow. The user is
able to inspect the result at each step in the chain, and it aligns well
with the \emph{grammar of graphics} and \emph{tidy data} workflows. This
makes \{detourr\} accessible to newcomers who may not have worked with
tours previously.

\hypertarget{interactivity}{%
\subsection{Interactivity}\label{interactivity}}

Presently, several well-developed R packages allow the use of web
technologies in R; \{HTMLWidgets\} allows binding R code with HTML and
JavaScript to create standalone widgets; \{shiny\} provides features for
combining various elements in to interactive web applications powered by
R; \{crosstalk\} (\citet{crosstalk}) enables linked selection and
brushing between different HTML Widgets; and \{rmarkdown\}
(\citet{rmarkdown}) allows creating HTML documents with HTML Widgets
embedded within. The use of web technologies such as JavaScript enable
the resulting visuals to be portable and accessible, and enable the
implementation of rich interactive features. In this section we will
describe these interactive features and how they can be configured.

\hypertarget{label-aesthetics}{%
\subsubsection{Label aesthetics}\label{label-aesthetics}}

In the above example, labels are defined within the call to
\texttt{tour\_aes()}, which contains all of the aesthetic mappings for
the tour. The \texttt{label} aesthetic produces a tooltip which is shown
whenever the mouse is hovered over the data point. By default, the text
in the tooltip will have the format \texttt{column\_name:\ value}, with
each specified column on a new line. If users want more control over
what appears in the tooltip, one can use the \texttt{I()} function so
that the values in the aesthetic column appear as-is. For example in
\ref{fig:hover-tooltip}, the left plot specifies the label aesthetic as
\texttt{label\ =\ c(InFit,\ Type,\ ID,\ pt,\ x,\ mu)} and the right is
specifies the label as-is by using \texttt{label\ =\ I(ID)} in the call
to \texttt{tour\_aes()}. When using the \texttt{I()} function for the
label aesthetic, only one column can be specified at a time.

\begin{Schunk}
\begin{figure}
\includegraphics[width=0.5\linewidth]{figures/implementation/hover_tooltip} \includegraphics[width=0.5\linewidth]{figures/implementation/hover_tooltip_asis} \caption[(left) Tooltip showing data from the 6 columns specified in the `label` aesthetic]{(left) Tooltip showing data from the 6 columns specified in the `label` aesthetic. Note that both the column names and values are present in the tooltip. (right) the `ID` column is provided as-is to the label aesthetic via the `I()` function.}\label{fig:hover-tooltip}
\end{figure}
\end{Schunk}

\hypertarget{controls}{%
\subsubsection{Controls}\label{controls}}

Table \ref{tab:pdf-controls} shows a breakdown of the controls found on
the left side of the visual. Note that the icon for the currently
selected control will be highlighted blue; otherwise it will be black.
When the icons are hovered over in the \texttt{show\_scatter()} widget,
alternative text will be shown.

\begin{Schunk}
\begin{table}

\caption{\label{tab:pdf-controls}An overview of the interactive controls available in the {detourr} displays}
\centering
\begin{tabular}[t]{>{\raggedright\arraybackslash}p{0.2\textwidth}>{\raggedright\arraybackslash}p{0.2\textwidth}>{\raggedright\arraybackslash}p{0.6\textwidth}}
\toprule
Control & Icon & Description\\
\midrule
Orbit & \raisebox{-\totalheight}{\includegraphics[width=0.2\textwidth]{figures/implementation/orbit_control_button.png}} & When the `show\_scatter()` widget is generated, orbit controls will be enabled by default. This allows click and drag to rotate the visual, and scrolling/pinching to zoom. Note that orbit controls for the 2D variant work best if dragging from left to right, not up and down. Also note that the icon for the currently selected control will be highlighted blue; otherwise it will be black.\\
\midrule
Pan & \raisebox{-\totalheight}{\includegraphics[width=0.2\textwidth]{figures/implementation/pan_button.png}} & The pan control also allows scrolling to zoom, and click and drag to pan.\\
\midrule
Box Selection & \raisebox{-\totalheight}{\includegraphics[width=0.2\textwidth]{figures/implementation/select_button.png}} & The selection control allows for transitory box selection by brushing. Holding the `shift` key will allow for persistent selection, and points outside of the selection will be indicated by increased transparency. There is currently a limitation where only visible points can be selected. If a point is completely obscured by other points, it will not be selected.\\
\midrule
Brush & \raisebox{-\totalheight}{\includegraphics[width=0.2\textwidth]{figures/implementation/brush.png}} & The brush button will apply the current colour to the selected points.\\
\midrule
Colour Selector & \raisebox{-\totalheight}{\includegraphics[width=0.2\textwidth]{figures/implementation/colour_selector.png}} & The colour selector will look slightly different depending on the browser being used. When the colour selection is changed, the selected points will be updated immediately.\\
\bottomrule
\end{tabular}
\end{table}

\end{Schunk}

\begin{Schunk}
\begin{figure}
\includegraphics[width=0.49\linewidth]{figures/implementation/pdfsense-brushing-1} \includegraphics[width=0.49\linewidth]{figures/implementation/pdfsense-brushing-2} \includegraphics[width=0.49\linewidth]{figures/implementation/pdfsense-brushing-3} \includegraphics[width=0.49\linewidth]{figures/implementation/pdfsense-brushing-4} \caption[An illustration of the box selection and brush tool being used together]{An illustration of the box selection and brush tool being used together.}\label{fig:brushing}
\end{figure}
\end{Schunk}

\hypertarget{timeline-controls}{%
\subsubsection{Timeline controls}\label{timeline-controls}}

The timeline at the bottom of the widget controls play and pause, and
allows for scrubbing to a specific point in the tour. The timeline can
also be used to jump to a specific basis by clicking on any of the white
basis markers, and hovering the mouse over the basis markers will
display the index of that basis.

\hypertarget{linked-selection-and-filtering}{%
\subsubsection{Linked selection and
filtering}\label{linked-selection-and-filtering}}

\{detourr\} supports linked selection and filtering by integrating with
\{crosstalk\}. When a \{crosstalk\} \texttt{SharedData} object is
provided to \texttt{detour()} in place of a data frame, selections made
using the \emph{box selection} tool will be reflected in all linked
visuals. Likewise, any selection or filtering applied to a linked visual
will be reflected by \{detourr\}. Compatible widgets include \{plotly\}
(\citet{plotly}), \{leaflet\} (\citet{leaflet}), and \{DT\}
(\citet{dt}). An example of this is shown in Section
\ref{sec:casestudylinked}.

\pagebreak

\hypertarget{ch:webtechnologies}{%
\section{Web technologies for performance}\label{ch:webtechnologies}}

One of the goals of this work is to improve upon the animation
performance of existing tour displays. \{detourr\} uses several
different web technologies to maximise performance so that smooth
animations can be played with large data sets consisting of upwards of
100k data points. This performance also enables the animations to work
with less powerful devices, making \{detourr\} accessible to a wider
range of users.

The primary technology that allows for high-performance data
visualisation is JavaScript itself. JavaScript engines in browsers such
as Chrome and Firefox are highly optimised, leveraging methods such as
Just-In-Time (JIT) compilation for improved runtime speed. However
JavaScript is single-threaded, dynamically typed, and garbage collected,
so despite these optimisations we can still run in to performance
bottlenecks in some situations.

Figure \ref{fig:dataflow} shows a simplified overview of the data flow
in \{detourr\} when creating and viewing a widget. On the left are the
operations that are performed by R, which only occur once when the
visual is first created and have a minimal performance impact. On the
right are the main operations performed by JavaScript when the widget is
displayed in a browser or IDE. Linear algebra and rendering operations
need to run 30 times per second, so the technology decisions surrounding
them have a big impact on performance. These technology decisions and
are discussed in this chapter.

\begin{Schunk}
\begin{figure}
\includegraphics[width=\textwidth]{detourr_files/figure-latex/dataflow-1} \caption[An overview of the data flow when creating a detourr visualisation]{An overview of the data flow when creating a detourr visualisation. The full tour path is generated in R and then passed to JavaScript when the widget is created. The operations that occur in the animation loop in JavaScript are the most important to optimise.}\label{fig:dataflow}
\end{figure}
\end{Schunk}

\hypertarget{linear-algebra-operations}{%
\subsection{Linear algebra operations}\label{linear-algebra-operations}}

The single-threaded nature of JavaScript makes matrix multiplication a
performance bottleneck. At each animation frame, we must calculate the
product \(\mathbf{XA}\) where \(\mathbf{X}\) is our data matrix and
\(\mathbf{A}\) is our projection matrix. The slice tour generated by the
\texttt{show\_slice()} display function requires an additional step of
calculating the distance from each point to the projection plane which
involves several more matrix operations.

To address this, \{detourr\} uses TensorFlow.js
(\citet{abadi2016tensorflow}) as the main library for storing data and
projection matrices and performing matrix operations. TensorFlow.js
requires the user chose between one of three available backends:

\textbf{CPU} is a single-threaded JavaScript implementation which
carries with it the limitations of JavaScript dynamic typing and garbage
collection causing non-deterministic slow-downs at runtime.

\textbf{WebAssembly} (WASM) is a binary format that is used as a
compilation target allowing code written in other languages like C, C++,
and Rust to be run in the browser. This circumvents the dynamic typing
and garbage collection limitations of JavaScript and allows near-native
execution speed. The TensorFlow WASM backend uses the XNNPACK library
from Google to accelerate matrix operations, which can run operations in
parallel using threads and SIMD (Single Instruction Multiple Data).

\textbf{WebGL}: uses WebGL shaders to perform matrix operations on the
GPU. According to the documentation, the performance benefit is
primarily seen with large and complex deep learning models, so is
unlikely to provide much benefit over the WebAssembly backend for our
use case, and so is not investigated further in this section.

\hypertarget{performance-comparison}{%
\subsection{Performance comparison}\label{performance-comparison}}

To compare these backend options a simple performance profile was run in
Microsoft Edge (Chromium) on a Macbook Pro 2019 (i7, 32Gb RAM). The
implementations that were compared were:

\begin{itemize}
\tightlist
\item
  \emph{Hand Coded}: a manual JavaScript implementation coded using
  \texttt{for} loops, operating on nested arrays representing data and
  projection matrices.
\item
  \emph{TensorFlow CPU}: the vanilla single-threaded CPU backend for
  TensorFlow.js.
\item
  \emph{TensorFlow WASM}: the TensorFlow.js WASM backend.
\end{itemize}

These backends were compared across 3 datasets of different sizes and
complexity, using a 2D Grand Tour:

\begin{itemize}
\tightlist
\item
  \emph{pdfsense}: The same data set used throughout this chapter; 2808
  observations across 56 variables, taking the first 6 principal
  components for the tour.
\item
  \emph{mnist\_embeddings\_8d}: 8-dimensional embeddings of the MNIST
  dataset, with a total of 10k observations.
\item
  \emph{mnist\_embeddings\_32d}: 32-dimensional embeddings of the MNIST
  dataset, again with 10k observations.
\end{itemize}

\begin{Schunk}
\begin{figure}
\includegraphics[width=\textwidth]{detourr_files/figure-latex/backend-comparison-1} \caption[Performance comparison across different data sets and backends]{Performance comparison across different data sets and backends. TensorFlow provides better performance than a hand-coded implementation across the board. For smaller datasets like pdfsense, there is little difference between CPU and WASM backends for TensorFlow.js, but for larger dataset WASM performs much better.}\label{fig:backend-comparison}
\end{figure}
\end{Schunk}

Figure \ref{fig:backend-comparison} shows the performance of the three
backends across the example datasets. TensorFlow provides better
performance across the board when compared to the hand-coded
implementation, but the difference between the CPU and WASM backends
only becomes apparent with the larger MNIST embeddings datasets. Note
that the metric \texttt{\%\ Scripting\ Time} is the time spent across
\emph{all} JavaScript scripting for the visual, and not just the time
spend on linear algebra operations. This is why we see such diminishing
returns with the smaller \emph{pdfsense} dataset.

Another important comparison is the performance of the
\texttt{show\_slice()} display function between these datasets. The
slice tour uses additional matrix operations to calculate the distance
from each point to the projection plane, so the benefit of WASM backend
is even more apparent. This is shown in Figure
\ref{fig:backend-comparison-slice}

\begin{Schunk}
\begin{figure}
\includegraphics[width=\textwidth]{detourr_files/figure-latex/backend-comparison-slice-1} \caption[The additional matrix operations required by the slice tour display function make the performance benefit of the WASM backend much more apparent]{The additional matrix operations required by the slice tour display function make the performance benefit of the WASM backend much more apparent.}\label{fig:backend-comparison-slice}
\end{figure}
\end{Schunk}

\hypertarget{rendering}{%
\subsection{Rendering}\label{rendering}}

When displaying data visuals using JavaScript in a browser, there are
three main technologies that can be used:

\textbf{SVG} is commonly used for web-based visuals, including in
software such as D3.js (\citet{bostock2011d3}) with good support for
interaction and animation. \citet{kipp2019connecting} uses D3.js with
SVG for rendering tours, but describes performance issues when the
number of points gets close to 2,000. This is because while SVG is
suitable for drawing large and complex shapes, performance can degrade
when rendering many individual shapes.

\textbf{HTML5 Canvas (2D)} uses a canvas element with a 2D rendering
context and provides good performance, allowing many thousand data
points to be used with smooth animation. This is the rendering method
used by the \{langevitour\} package, and provides much better
performance over SVG for this use case.

\textbf{HTML5 Canvas (WebGL)} uses the WebGL rendering context with GPU
acceleration to achieve high performance, and is used by a range of
browser-based 3D animations and games. This typically provides higher
performance than using the 2D canvas rendering context.

\{detourr\} implements \textbf{HTML5 Canvas} with the \textbf{WebGL}
rendering context using the Three.js (\citet{threejs}) library. This is
the same library that powers the TensorFlow Embedding Projector
(\citet{smilkov2016embedding}), and allows for flexible and performant
2D and 3D data visuals.

One downside of using HTML5 Canvas elements is that custom logic is
needed to determine where the mouse pointer is relative to visual
elements when interactions occur. This issue is resolved is by rendering
the image twice; the first pass renders to the screen and the second
renders to an invisible `picking' scene. The colours of the points in
this picking scene correspond to the ID of the point that was rendered.
When a mouse is hovered over a pixel or a set of pixels are selected, we
simply check their colour in the picking scene to determine which point
IDs relate to the event. Rendering the scene twice at each frame makes
performance all the more important.

Despite this extra step, a naive performance benchmark of the rendering
performance of \{detourr\} using the \texttt{mnist\_embeddings\_8d} data
set at 30 FPS shows only 3\% of the time is devoted to rendering and
painting points, which for our use case is negligible.

\pagebreak

\hypertarget{ch:casestudy}{%
\section{Case study --- MNIST embeddings}\label{ch:casestudy}}

A common task when analysing wide or sparse data sets is to generate
embeddings; finding a lower dimensional representation of high
dimensional data, placing similar objects close together and dissimilar
objects far apart in the embedding space. This is especially useful when
dealing with text or image data.

An example of this is the algorithm used for facial recognition in
FaceNet (\citet{schroff2015facenet}). A neural network is trained which
maps a vector representation of images of faces to a lower dimensional
space. The network minimises the distance between examples of the same
class and maximises distances between examples from different classes in
the output space. The result is that the euclidean distance between
faces can be used as a metric for face similarity, so an unknown face
can be classified as belonging to a specific individual if the distance
between the unknown face and one or more known faces is small.

The datasets \texttt{mnist\_embeddings\_8d} and
\texttt{mnist\_embeddings\_32d} in the \{detourr\} package are
embeddings trained using a similar algorithm to FaceNet but using the
MNIST (\citet{lecun1998mnist}) handwritten digits dataset. The training
set consists of 60,000 28x28 pixel training images and in the following
examples we visualise the test set containing 10,000 examples.

\hypertarget{scatterplot-display}{%
\subsection{Scatterplot display}\label{scatterplot-display}}

\begin{Schunk}
\begin{figure}

{\centering \includegraphics[width=0.49\linewidth]{figures/mnist/mnist-8d-scatter-1} \includegraphics[width=0.49\linewidth]{figures/mnist/mnist-8d-scatter-2} \includegraphics[width=0.49\linewidth]{figures/mnist/mnist-8d-scatter-label} \includegraphics[width=0.49\linewidth]{figures/mnist/mnist-8d-scatter-timeline} 

}

\caption[Selected frames from the 8-dimensional MNIST embeddings data using show\_scatter() as the display method]{Selected frames from the 8-dimensional MNIST embeddings data using show\_scatter() as the display method. The colour corresponds to the handwritten digit 0, 1, ..., 9. Despite the large number of data points, the animation of the tour is smooth and interactions are responsive.}\label{fig:mnist-8d-scatter}
\end{figure}
\end{Schunk}

Using the core \texttt{show\_scatter()} function to display a
\texttt{grand\_tour()} tour path in
\href{mailto:Figure@ref}{\nolinkurl{Figure@ref}}(fig:mnist-8d-scatter)
we can see quite good separation between the clusters corresponding to
each of the 10 digits. Despite the tour animation consisting of 10,000
data points, the animation runs smoothly at 30 FPS in Microsoft Edge on
a Macbook Pro 2019. Running a performance profile of the animation
indicates the CPU is idle 90\% of the time while the animation is
playing. The remaining time is divided between scripting (6\%, including
linear algebra operations), rendering (1.4\%), painting (0.8\%) and
system (1.8\%). When running the same tour on the
\texttt{mnist\_embeddings\_32d} dataset, the animation is still quite
smooth and CPU is 80\% idle.

In the lower left of
\href{mailto:Figure@ref}{\nolinkurl{Figure@ref}}(fig:mnist-8d-scatter)
is an example of the \texttt{label} aesthetic at work. This allows the
user to identify which group a set of points belongs to, as well as the
precise ID of any outliers that may require further investigation.

\hypertarget{sage-and-slice-display-methods}{%
\subsection{Sage and Slice display
methods}\label{sage-and-slice-display-methods}}

The \texttt{show\_scatter()} display method gives the viewer a fairly
good sense of the data set, but there is some structure that may not be
obvious. The embeddings in the \texttt{mnist\_embeddings\_8d} and
\texttt{mnist\_embeddings\_32d} datasets are L2 normalised, so the
points sit on the surface of a unit ball in the high-dimensional space.
To reveal this structure, we can use the \emph{sage}
(\citet{laa2021burning}) or \emph{slice} (\citet{laa2020slice}) display
methods, which are implemented as \texttt{show\_sage()} and
\texttt{show\_slice()} respectively.

The \emph{sage} display scales points outwards based on their radius so
that the relative volume of the circle or sphere in the projected space
is the same as in the original space. In the example shown in
\href{mailto:Figure@ref}{\nolinkurl{Figure@ref}}(fig:mnist-8d-sage), the
\texttt{show\_sage()} display method is used. The effect is that the
projected points tend sit much closer to the surface of the unit circle,
giving a much clearer view of the ball-like structure of the original
data.

\begin{Schunk}
\begin{figure}

{\centering \includegraphics[width=0.49\linewidth]{figures/mnist/mnist-8d-slice-1} \includegraphics[width=0.49\linewidth]{figures/mnist/mnist-8d-slice-2} 

}

\caption[selected frames of the 8-dimensional MNIST embeddings data using show\_slice() as the display method]{selected frames of the 8-dimensional MNIST embeddings data using show\_slice() as the display method. The slice display makes the hollowness of this data apparent.}\label{fig:mnist-8d-slice}
\end{figure}
\end{Schunk}

The \emph{slice} display highlights points based on their proximity to
the projection plane. Points that are close to the projection plane are
highlighted and those further away are faded out by making them
transparent. In the case of the MNIST embedding data in
\href{mailto:Figure@ref}{\nolinkurl{Figure@ref}}(fig:mnist-8d-slice) the
ball structure of the data manifests as a clear circular void in the
middle of the plot, with points highlighted only towards the edges.

\hypertarget{sec:casestudylinked}{%
\subsection{Linked selection}\label{sec:casestudylinked}}

Plot interactions such as selection and filtering can be helpful for
identifying and exploring outliers, clusters, and other interesting
features in a dataset. These are enhanced even further when multiple
visuals are linked, and selections and filters are applied to all linked
visuals. In this example, we compare the tour animation with the result
of a T-SNE (\citet{van2008tsne}) which was performed using the excellent
\{Rtsne\} R package (\citet{van2015rtsne}) and displayed using
\{plotly\}. The visuals are linked using the R package \{crosstalk\}
(\citet{crosstalk}) and a set of filter checkboxes is also added.

\begin{Schunk}
\begin{figure}
\includegraphics[width=\textwidth]{figures/mnist/case-study-linked-brushing-full} \caption[Linked visuals of the tour using {detourr} (left) compared to a T-SNE dimension reduction (right)]{Linked visuals of the tour using {detourr} (left) compared to a T-SNE dimension reduction (right)}\label{fig:linked-tsne-full}
\end{figure}
\end{Schunk}

Figure \ref{fig:linked-tsne-full} shows the linked visuals in their
initial state with no filtering applied. We can then use the selection
tool in either of the visuals to highlight points, and see the
highlighting applied to both visuals as in
\href{mailto:Figure@ref}{\nolinkurl{Figure@ref}}(fig:linked-tsne-selection).

\begin{Schunk}
\begin{figure}
\includegraphics[width=\textwidth]{figures/mnist/case-study-linked-brushing-selection} \caption[Linked visuals with selection applied]{Linked visuals with selection applied. Points can be selected in either visual via click-and-drag and the selection will be reflected in both.}\label{fig:linked-tsne-selection}
\end{figure}
\end{Schunk}

Figure \ref{fig:linked-tsne-filter} shows the result of filtering the
visuals using the filter checkboxes on the left. In the filtered visual,
outlying points are much easier to see, and they can be easily
investigated using tooltips.

\begin{Schunk}
\begin{figure}
\includegraphics[width=\textwidth]{figures/mnist/case-study-linked-brushing-filter} \caption[Linked visuals with filtering applied]{Linked visuals with filtering applied. Viewing each digit individually makes outlying points much more apparent, and those points can be identified using tooltips.}\label{fig:linked-tsne-filter}
\end{figure}
\end{Schunk}

\pagebreak

\hypertarget{ch:futurework}{%
\section{Conclusion and future work}\label{ch:futurework}}

In this paper we have introduced \{detour\} which provides interactive,
performant, and portable tour visualisations from R. We accomplish these
things using web technolies; TensorFlow.js (\citet{abadi2016tensorflow})
provides fast linear algebra operations through WebAssembly, Three.js
provides GPU rendering via WebGL, and JavaScript \& HTML enable good
performance and interactive features across the board. We also provide a
simplified implementation of the Slice display (\citet{laa2020slice}),
and have generalised the radial transformation from the Sage display
(\citet{laa2021burning}) to work with tours of 3 or more dimensions. All
of this is done with an intuitive user interface which makes the
software accessible to new users.

Looking ahead, the priority for the next stage of development is to
leverage \{detourr\}'s extensible design to implement additional display
methods such as density plots, histograms, parallel coordinates plots,
and Andrew's plot. Additional changes could also be made to allow the
radial transformation of the sage display and the highlighting of points
from the slice display to be incorporated in to these other display
methods, rather than being limited to only the scatter plot display.
This would also allow the additional information from both the sage and
slice tour applied to the same visual.

Further enhancements could be made by implementing facetting; allowing
grouped data to be displayed across separate visuals with unified
controls and timeline added. This could be taken further by allowing
multiple \emph{different} displays to use the same controls and
timeline, for example displaying a scatter plot alongside one or more
density plots.

To extend the existing scatter plot displays, the addition of an
interactive legend would greatly enhance the user experience. As well as
providing context for the point colour / fill, this would allow the user
to be able to filter groups without needing to use a separate package
like \{shiny\} or \{crosstalk\}. A shape aesthetic would also be
beneficial, and the ability to export the projection matrix at the
current frame would make it easier to perform analysis once an
interesting projection is found.

As well as being able to display points and lines, support for plotting
surfaces would allow for rich visualisations of regression model fits
and classification boundaries. Three.js has good support for drawing
surfaces, however it's not clear how a decision boundary can be
projected down to a lower number of dimensions or whether this is
actually feasible.

Support for displaying images or sprites directly on the tour visual or
as an extension of the tooltip functionality is possible. A similar
feature is implemented in the Tensorboard Embedding Visualiser
(\citet{smilkov2016embedding}) which also uses Three.js under the hood.

What's more, Three.js has support for VR, which would be an interesting
addition for exploring an immersive 3D tour visual.

\hypertarget{appendix}{%
\section{Appendix}\label{appendix}}

\hypertarget{app:a}{%
\subsection{Radial CDF of hyperspheres projected to 3
dimensions}\label{app:a}}

In order to implement the 3D variant of the sage tour
(\citet{laa2021burning}), we need an expression for the relative
projected volume of a \textbf{sphere} of radius \(R\). This is then used
as a scaling factor for point radii in the visualisation to prevent
points from being crowded towards the center.

First we denote the volume of a \(p\)-dimensional hypersphere by:

\[
\frac{2\pi^{p/2}R^p}{p\Gamma(p/2)}
\]

In the appendix of \citet{laa2020hole} (equations 7--10) is a derivation
for the relative projected volume of a ball of radius \(r\).

\begin{align}
    F(r; p, R) &= \frac{V_{inside}(r; p, R)}{ V(p, r) } \\
    &= 1 - \frac{V_{outside}(r; p, R)}{ V(p, r) }
    \label{eq:F2}
\end{align}

And the formula for \(V_{outside}(r; p, R)\) for a \textbf{circle} is
given as:

\begin{equation}
V_{outside}(r; p, R) =
\int_r^R V(p-2, \sqrt{R^2 - x^2})2\pi x dx 
\label{eq:v-outside}
\end{equation}

To extend this to the 3-dimensional case, we can modify
\eqref{eq:v-outside} to express the volume outside a \textbf{sphere} of
radius \(r\) as:

\begin{equation}
  V_{outside}(r; p, R) = \int_r^R V(p-3, \sqrt{R^2 - x^2})4\pi x^2 dx
\end{equation}

and it follows that the relative projected volume for a sphere is

\begin{equation}
  F_3(r; p, R) = 1 - 
  \frac{
      \int_r^R V(p-3, \sqrt{R^2 - x^2})4\pi x^2 dx
  }{
      V(p, R)
  } 
\end{equation}

We know \(2\Gamma(3/2) = \Gamma(1/2) = \sqrt{ \pi }\) so with some
rearranging this can be reduced to:

\begin{equation}
  F_3(r; p, R) = 1 - \frac{2}{R^p} \frac{\Gamma(p/2+1)}{\Gamma(3/2)\Gamma((p-1)/2)}
  \int_r^R (R^2 - x^2)^{(p-3)/2} x^2 dx \\
\end{equation}

Denoting \(u = 1 - \left(\frac{x}{R}\right)^2\) and
\(dx = \frac{R^2}{-2x}du = \frac{R}{-2\sqrt{1-u}}du\) for a change of
variable this becomes

\begin{align}
  F_3(r; p, R) &= 1 - \frac{\Gamma(p/2+1)}{\Gamma(3/2)\Gamma((p-1)/2)}
  \int_0^{1-\frac{r^2}{R^2}} u^{(p-3)/2} (1-u)^{1/2} du \\
  &= 1 - \mathrm{BetaInc}\left(1-\left(\frac{r}{R}\right)^2, \frac{p-1}{2}, \frac{3}{2}\right) \\
  &= \mathrm{BetaInc}\left(\left(\frac{r}{R}\right)^2, \frac{3}{2}, \frac{p-1}{2}\right) 
  \label{eq:betainc1}
\end{align}

where \emph{BetaInc} is the regularised incomplete beta function (the
CDF of a Beta distribution).

We can generalise this to any projection from \(p\) to \(d\) dimensions
using the same steps, but with

\begin{equation}
  V_{outside}(r; p, R, d) = \int_r^R V(p-d, \sqrt{R^2 - x^2}) 
  \frac{2\pi^{d/2}}{\Gamma(d/2)} x^{d-1} dx
\end{equation}

where \(\frac{2\pi^{d/2}}{\Gamma(d/2)} x^{d-1}\) is the surface area of
a d-ball.

This results in the relative projected volume of a projection from \(p\)
to \(d\) dimesions being given by:

\begin{equation}
F(r; p, R, d) = \mathrm{BetaInc}\left(\left(\frac{r}{R}\right)^2, \frac{d}{2}, \frac{p-d}{2}+1\right)
\label{eq:betainc2}
\end{equation}

Figures \ref{fig:radial-cdf-p} and \ref{fig:radial-cdf-d} compare the
theoretical results from equations \eqref{eq:betainc1} and
\eqref{eq:betainc2} respectively with simulated values.

\begin{Schunk}
\begin{figure}
\includegraphics{detourr_files/figure-latex/radial-cdf-p-1} \caption[Relative projected volume for projections from p dimensions to d=3 dimensions]{Relative projected volume for projections from p dimensions to d=3 dimensions. The solid line is simulated data, and the dashed line is the theoretical CDF}\label{fig:radial-cdf-p}
\end{figure}
\end{Schunk}

\begin{Schunk}
\begin{figure}
\includegraphics{detourr_files/figure-latex/radial-cdf-d-1} \caption[Relative projected volume for a projection of p=10 dimensions to d dimensions]{Relative projected volume for a projection of p=10 dimensions to d dimensions.  The solid line is simulated data, and the dashed line is the theoretical CDF. This shows the generalisation to d > 3 dimensions}\label{fig:radial-cdf-d}
\end{figure}
\end{Schunk}

\bibliography{RJreferences.bib}

\address{%
Casper Hart\\
University of Auckland\\%
\\
%
%
%
%
}
